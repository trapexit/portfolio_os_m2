/* @(#) vcprintf.c 96/04/17 1.44 */

/**
|||	AUTODOC -public -class ANSI_C -name printf
|||	-visible_alias fprintf
|||	-visible_alias sprintf
|||	-visible_alias vprintf
|||	-visible_alias vfprintf
|||	-visible_alias vsprintf
|||	-visible_alias cprintf
|||	-visible_alias vcprintf
|||	Standard C formatting routines.
|||
|||	  Synopsis
|||
|||	    int printf(const char *format, ...);
|||
|||	    int fprintf(FILE *file, const char *format, ...);
|||
|||	    int sprintf(char *s, const char *format, ...);
|||
|||	    int cprintf(const char *format, OutputFunc of, void *userData, ... );
|||
|||	    int vprintf(const char *format, va_list a);
|||
|||	    int vfprintf(FILE *file, const char *format, va_list a);
|||
|||	    int vsprintf(char *s, const char *format, va_list a);
|||
|||	    int vcprintf(const char *format, OutputFunc of, void *userData,
|||	                 va_list va);
|||
|||	  Description
|||
|||	    printf() converts a formatting string and a series of arguments to
|||	    a string of ASCII characters which is output to the debugging
|||	    terminal.
|||
|||	    The other functions listed above operate in a very similar way,
|||	    except that they generate their characters into an arbitrary file
|||	    (fprintf() or vfprintf()), generated their output into a string
|||	    buffer that gets NULL terminated (sprintf() or vsprintf()), or
|||	    invoke a callback function for every character generated
|||	    (cprintf() or vcprintf()).
|||
|||	    The format argument points to a string containing characters to
|||	    output, along with special conversion specifications. These
|||	    conversion specs indicate how to interpret the extra arguments
|||	    given to this function. The specs are replaced in the output
|||	    string by arguments converted according to the specifications.
|||
|||	    A conversion specification begins with a percent sign (%).
|||	    To place an ordinary percent into the output stream, precede
|||	    it with another percent in the format string. That is, %% will send
|||	    a single percent character to the output stream. A conversion
|||	    specification has the following format:
|||
|||	    %[flags][width][.precision]type
|||
|||	    The flags field controls output justification and the printing of
|||	    signs, blanks, decimal places, and hexadecimal prefixes. The
|||	    following flags may be specified in any order:
|||
|||	    - (minus)
|||	        Causes the result to be left-justified within the
|||	        field specified by width or within the default width.
|||
|||	    + (plus)
|||	        Causes a plus or minus sign to be placed before the
|||	        result. This flag is used in conjunction with the
|||	        various numeric conversion types. If it is absent,
|||	        the sign character is generated only for a negative
|||	        number.
|||
|||	    <blank>
|||	        Causes a leading blank for a positive number and a
|||	        minus sign for a negative number. This flag is
|||	        similar to the plus (+) flag. If both the plus (+) and the
|||	        blank flags are present, the plus (+) takes precedence.
|||
|||	    # (pound)
|||	        Causes special formatting. With the %o, %x, and %X
|||	        types, this flag prefixes any output with 0, 0x, or 0X,
|||	        respectively. With the %p type, this flag prefixes any output
|||	        with @. With the %f, %e, and %E types, this flag forces the
|||	        result to contain a decimal point. With the %g and %G types,
|||	        this flag forces the result to contain a decimal point and
|||	        retain trailing zeroes.
|||
|||	    0 (zero)
|||	        Pads the field width with leading zeroes instead of
|||	        spaces for the %d, %i, %o, %u, %x, %X, %e, %E, %f, %g, and
|||	        %G conversion types. If the minus (-) flag is also used, the
|||	        zero flag is ignored. If a precision is specified,
|||	        this flag is ignored for conversion types %d, %i, %o,
|||	        %u, %x, and %X.
|||
|||	    The width is a number >= 0 that specifies the minimum field width.
|||	    If fewer characters are generated by the conversion operation, the
|||	    result is padded on the left or right, depending on the presence of
|||	    the minus (-) flag. A blank is used as the padding character unless
|||	    the 0 flag was specified, in which case padding with zeroes is
|||	    performed. If the minus (-) flag appears, padding is performed with
|||	    blanks.
|||
|||	    If you do not want to specify the field width as a constant in the
|||	    format string, you can code it as an asterisk (*). The asterisk
|||	    indicates that the width value is a 32-bit integer in the argument
|||	    list.
|||
|||	    The precision value specifies the field precision, which is the
|||	    required precision of floating-point conversions, the maximum
|||	    number of characters to be copied from a string, or the minimum
|||	    number of digits to output for integer conversions.
|||
|||	    The meaning of the precision value depends on the conversion type.
|||	    For %c, the precision value is ignored. For %d, %i, %o, %u, %x,
|||	    and %X, the precision value specifies the mininum number of digits
|||	    to output, and zero padding to the left is supplied if fewer digits
|||	    are generated. For %e, %E, and %f the precision is the number of
|||	    digits to appear after the decimal point. If fewer digits are
|||	    generated, trailing zeroes are supplied. For %g and %G, the
|||	    precision is the maximum number of significant digits. Finally,
|||	    for %s, the precision is the maximum number of characters to be
|||	    copied from the string.
|||
|||	    As with the width value, you can use an asterisk (*) for the
|||	    precision to indicate that the value should be picked up
|||	    from the argument list.
|||
|||	    The type field is a one or two letter sequence specifying the
|||	    argument conversion to perform. The possible values are:
|||
|||	    c
|||	        Specifies a single-character conversion. The associated
|||	        argument is a 32-bit integer. The low byte of this integer
|||	        is output.
|||
|||	    d
|||	        Specifies a signed decimal integer conversion. The associated
|||	        argument is a signed 32-bit integer, and the result is a string
|||	        of digits preceded by a sign. If the plus (+) and blank flags
|||	        are absent, the sign is produced only for a negative integer.
|||
|||	    e
|||	        Specifies a floating-point conversion. The associated argument
|||	        is a floating-point number, and the result has the form:
|||
|||	        [-]s.dddddde[+/-]ee
|||
|||	        where s is a single decimal digit, dddddd is one or more digits,
|||	        and ee is an exponent of at least two digits. The plus (+) and
|||	        blank flags dictate whether there will be a leading sign
|||	        character emitted if the number is positive. One digit is
|||	        output before the decimal point, and the number of digits
|||	        output after the decimal point depends on the requested
|||	        precision. The value is rounded to the specified number of
|||	        digits. If no precision is specified, the default is
|||	        six decimal places.
|||
|||	    E
|||	        Is identical to %e, except that the result has the form:
|||
|||	        [-]s.ddddddE[+/-]ee
|||
|||	    f
|||	        Specifies a floating-point conversion. The associated argument
|||	        is a floating-point number, and the result has the form:
|||
|||	        [-]sss.dddddd
|||
|||	        where sss indicates one or more decimal digits. The minus sign
|||	        is omitted if the number is positive, but a sign character will
|||	        still be generated if the plus (+) or blank flag is present. The
|||	        number of digits before the decimal point depends on the
|||	        magnitude of the number, and the number of digits output after
|||	        the decimal point depends on the requested precision. If no
|||	        precision is specified, the default is six decimal places. If
|||	        the precision is specified as 0, or if there are no nonzero
|||	        digits to the right of the decimal point, then the decimal
|||	        point is omitted unless the pound (#) flag is specified.
|||
|||	    g
|||	        Specifies a floating-point conversion. The associated
|||	        argument is a floating-point number, and the result is
|||	        identical to %e or %f depending on which gives the most
|||	        compact result. The %e format is used only when the exponent is
|||	        less than -4 or greater than the specified or default precision.
|||	        Trailing zeroes are eliminated, and the decimal point appears
|||	        only if any nonzero digits follow it.
|||
|||	    G
|||	        Is identical to %g, except that %E gets used instead of %e.
|||
|||	    hn
|||	        Is identical to %n, except that the argument is a pointer to
|||	        a 16-bit integer instead of a 32-bit one.
|||
|||	    i
|||	        Specifies a signed decimal integer conversion. The associated
|||	        argument is a 32-bit integer, and the result is a string of
|||	        digits preceded by a sign. If the plus (+) and blank flags are
|||	        absent, the sign is produced only for a negative integer.
|||
|||	    ld, li, lo, lu, lx, lX
|||	        Synonyms for %d, %i, %o, %u, %x, and %X respectively.
|||
|||	    Ld, Li, Lo, Lu, Lx, LX
|||	        Identical to %d, %i, %o, %u, %x, and %X respectively,
|||	        except that the associated argument is a 64-bit quantity
|||	        instead of a 32-bit one.
|||
|||	    Ln
|||	        Is identical to %n, except that the argument is a pointer to
|||	        a 64-bit integer instead of a 32-bit one.
|||
|||	    n, ln
|||	        Specifies the argument is a pointer to a 32-bit integer into
|||	        which should be written the number of characters output so far
|||	        during this formatting operation.
|||
|||	    o
|||	        Specifies an unsigned octal integer conversion. The associated
|||	        argument is an unsigned 32-bit integer, which is output in
|||	        octal format.
|||
|||	    p
|||	        Specifies a pointer conversion. The associated argument is
|||	        taken as a 32-bit pointer value, and it is converted to
|||	        hexadecimal. The default field precision is set to 8 for this
|||	        conversion. The pound (#) flag causes a '@' symbol to be
|||	        used as a prefix.
|||
|||	    P
|||	        Is identical to %p, except that it uses uppercase letters to
|||	        represent the hexadecimal digits.
|||
|||	    s
|||	        Specifies a string conversion. The associated argument points
|||	        to a character string. The string is copied to the output, up
|||	        until a null byte is encountered, or the field precision is
|||	        reached.
|||
|||	    u
|||	        Specifies an unsigned decimal integer conversion. The
|||	        associated argument is a 32-bit unsigned integer, which is
|||	        output in decimal format.
|||
|||	    x
|||	        Specifies an unsigned hexadecimal-integer conversion. The
|||	        associated argument is an unsigned 32-bit integer,
|||	        which is output in hexadecimal format using lowercase letters.
|||
|||	    X
|||	        Is identical to %x, except that is uses uppercase letters to
|||	        represent the hexadecimal digits.
|||
|||	  Implementation Details
|||
|||	    The following are minor extensions to the ANSI C standard, and
|||	    implementation-defined behaviors for this function:
|||
|||	    1 - The %Ld, %Li, %Lo, %Lu, %Lx, and %LX conversions types
|||	    were added to deal with 64-bit integers.
|||
|||	    2 - The %P conversion type was added. It is identical to %p,
|||	    except that uppercase hexadecimal digits are used instead of
|||	    lowercase ones.
|||
|||	    3 - Unless a width is explicitly supplied, the default width for
|||	    %p and %P is set to 8 hexadecimal digits.
|||
|||	    4 - Supplying a NULL pointer to a %s conversion type will generate
|||	    the output string "<NULL>".
|||
|||	    5 - The pound (#) flags outputs a leading 0 for %o values other
|||	    than 0, 0x for %x, 0X for %X, and @ for %p and %P.
|||
|||	    6 - The IEEE floating-point indeterminate values of infinity and
|||	    not-a-number are output as "Infinity" and "NaN" respectively.
|||
|||	  Arguments
|||
|||	    format
|||	        The format string describing the output process.
|||
|||	    ...
|||	        The optional arguments containing the data to be used
|||	        during output. There must be enough arguments specified to
|||	        satisfy the needs of the formatting string, otherwise
|||	        strange output, or maybe even a crash, will occur.
|||
|||	  Return Value
|||
|||	    Returns the number of characters output or a negative error code
|||	    for failure.
|||
|||	  Associated Files
|||
|||	    <stdio.h>, libc.a
|||
**/


/* Undefine this to compile the code to run under UNIX. See main() at the
 * bottom to see how to test things.
 */
#define FOR_PORTFOLIO

#ifdef FOR_PORTFOLIO
#include <kernel/debug.h>
#include <kernel/kernel.h>
#include <kernel/internalf.h>
#endif
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


/*****************************************************************************/


#ifndef FOR_PORTFOLIO
#define FLOAT  double
#define TRUE   1
#define FALSE  0

typedef int         (* OutputFunc)(int ch, void *userData);
typedef unsigned char  uint8;
typedef short          int16;
typedef unsigned short uint16;
typedef int            int32;
typedef unsigned int   uint32;
typedef unsigned int   uint64;
typedef int            int64;
typedef char           bool;

#else

#define FLOAT float

#endif


/*****************************************************************************/


#define FLG_SHORT     (1 << 0)
#define FLG_LONG      (1 << 1)
#define FLG_DLONG     (1 << 2)
#define FLG_ZERO      (1 << 3)
#define FLG_PLUS      (1 << 4)
#define FLG_MINUS     (1 << 5)
#define FLG_SPACE     (1 << 6)
#define FLG_HASH      (1 << 7)

#define output(ch) {error = (*of)(ch,userData); if (error < 0) goto exit; else numChars++;}


/*****************************************************************************/


typedef struct
{
    char   lb_Buffer[64];
    uint32 lb_NumBytes;
} LineBuffer;


/*****************************************************************************/


static void FlushLineBuffer(LineBuffer *lb)
{
    lb->lb_Buffer[lb->lb_NumBytes] = 0;

#ifdef FOR_PORTFOLIO
    if (IsSuper())
    {
        internalDebugPutStr(lb->lb_Buffer);
    }
    else
    {
        DebugPutStr(lb->lb_Buffer);
    }
#else
    printf("%s",lb->lb_Buffer);
#endif

    lb->lb_NumBytes = 0;
}


/*****************************************************************************/


static int32 DefaultOutputFunc(char ch, LineBuffer *lb)
{
    lb->lb_Buffer[lb->lb_NumBytes++] = ch;

    if ((ch == '\n') || (lb->lb_NumBytes == sizeof(lb->lb_Buffer)-1))
        FlushLineBuffer(lb);

    return 0;
}


/*****************************************************************************/


typedef uint32 uint128[4];
typedef uint32 uint192[6], *uint192Ptr;

static const uint128 tensTable[] =
{
    0x00000000, 0x00000000, 0x00000000, 0x00000001, /* 10 ** 0 */
    0x00000000, 0x00000000, 0x00000000, 0x0000000a, /* 10 ** 1 */
    0x00000000, 0x00000000, 0x00000000, 0x00000064, /* 10 ** 2 */
    0x00000000, 0x00000000, 0x00000000, 0x000003e8, /* 10 ** 3 */
    0x00000000, 0x00000000, 0x00000000, 0x00002710, /* 10 ** 4 */
    0x00000000, 0x00000000, 0x00000000, 0x000186a0, /* 10 ** 5 */
    0x00000000, 0x00000000, 0x00000000, 0x000f4240, /* 10 ** 6 */
    0x00000000, 0x00000000, 0x00000000, 0x00989680, /* 10 ** 7 */
    0x00000000, 0x00000000, 0x00000000, 0x05f5e100, /* 10 ** 8 */
    0x00000000, 0x00000000, 0x00000000, 0x3b9aca00, /* 10 ** 9 */
    0x00000000, 0x00000000, 0x00000002, 0x540be400, /* 10 ** 10 */
    0x00000000, 0x00000000, 0x00000017, 0x4876e800, /* 10 ** 11 */
    0x00000000, 0x00000000, 0x000000e8, 0xd4a51000, /* 10 ** 12 */
    0x00000000, 0x00000000, 0x00000918, 0x4e72a000, /* 10 ** 13 */
    0x00000000, 0x00000000, 0x00005af3, 0x107a4000, /* 10 ** 14 */
    0x00000000, 0x00000000, 0x00038d7e, 0xa4c68000, /* 10 ** 15 */
    0x00000000, 0x00000000, 0x002386f2, 0x6fc10000, /* 10 ** 16 */
    0x00000000, 0x00000000, 0x01634578, 0x5d8a0000, /* 10 ** 17 */
    0x00000000, 0x00000000, 0x0de0b6b3, 0xa7640000, /* 10 ** 18 */
    0x00000000, 0x00000000, 0x8ac72304, 0x89e80000, /* 10 ** 19 */
    0x00000000, 0x00000005, 0x6bc75e2d, 0x63100000, /* 10 ** 20 */
    0x00000000, 0x00000036, 0x35c9adc5, 0xdea00000, /* 10 ** 21 */
    0x00000000, 0x0000021e, 0x19e0c9ba, 0xb2400000, /* 10 ** 22 */
    0x00000000, 0x0000152d, 0x02c7e14a, 0xf6800000, /* 10 ** 23 */
    0x00000000, 0x0000d3c2, 0x1bcecced, 0xa1000000, /* 10 ** 24 */
    0x00000000, 0x00084595, 0x16140148, 0x4a000000, /* 10 ** 25 */
    0x00000000, 0x0052b7d2, 0xdcc80cd2, 0xe4000000, /* 10 ** 26 */
    0x00000000, 0x033b2e3c, 0x9fd0803c, 0xe8000000, /* 10 ** 27 */
    0x00000000, 0x204fce5e, 0x3e250261, 0x10000000, /* 10 ** 28 */
    0x00000001, 0x431e0fae, 0x6d7217ca, 0xa0000000, /* 10 ** 29 */
    0x0000000c, 0x9f2c9cd0, 0x4674edea, 0x40000000, /* 10 ** 30 */
    0x0000007e, 0x37be2022, 0xc0914b26, 0x80000000, /* 10 ** 31 */
    0x000004ee, 0x2d6d415b, 0x85acef81, 0x00000000, /* 10 ** 32 */
    0x0000314d, 0xc6448d93, 0x38c15b0a, 0x00000000, /* 10 ** 33 */
    0x0001ed09, 0xbead87c0, 0x378d8e64, 0x00000000, /* 10 ** 34 */
    0x00134261, 0x72c74d82, 0x2b878fe8, 0x00000000, /* 10 ** 35 */
    0x00c097ce, 0x7bc90715, 0xb34b9f10, 0x00000000, /* 10 ** 36 */
    0x0785ee10, 0xd5da46d9, 0x00f436a0, 0x00000000, /* 10 ** 37 */
    0x4b3b4ca8, 0x5a86c47a, 0x098a2240, 0x00000000  /* 10 ** 38 */
};


/*****************************************************************************/


static bool Compare_uint128(const uint128 a, const uint128 b)
{
uint32 i;

    for (i = 0; i < 4; i++)
    {
        if (a[i] > b[i])
            return TRUE;

        if (a[i] < b[i])
            return FALSE;
    }

    return FALSE;
}


/*****************************************************************************/


static void ShiftLeft_uint192(uint192 value, uint32 shiftCount)
{
uint32 i;

    for (i = 0; i < 5; i++)
        value[i] = (value[i] << shiftCount) | (value[i + 1] >> (32 - shiftCount));

    value[5] = (value[5] << shiftCount);
}


/*****************************************************************************/


static void Add_uint192(uint192 a, uint192 b, uint192 sum)
{
uint32 long_a;
uint32 long_b;
int32  i;
bool   carry;

    carry = FALSE;
    for (i = 5; i >= 0; --i)
    {
        long_a = a[i];
        long_b = b[i];
        sum[i] = long_a + long_b;

        if (carry)
            sum[i]++;

        if ((0xffffffff - long_a) < long_b)
            carry = TRUE;
        else
            carry = FALSE;
    }
}


/*****************************************************************************/


static void Mult10_uint192(uint192 value)
{
uint192 temp;
uint32  i;

    for (i = 0; i < 6; i++)
        temp[i] = value[i];

    ShiftLeft_uint192(value, 3);
    Add_uint192(temp, value, value);
    Add_uint192(temp, value, value);
}


/*****************************************************************************/


static void Subtract_uint128(uint128 a, const uint128 b, uint128 difference)
{
uint128 temp;
int32   i;
bool    borrow;

    borrow = FALSE;

    for (i = 0; i < 4; i++)
        temp[i] = a[i];

    for (i = 3; i >= 0; --i)
    {
        if (borrow)
            temp[i]--;

        if ((temp[i] < b[i]) || (borrow && (temp[i] == 0xFFFFFFFF)))
            borrow = TRUE;
        else
            borrow = FALSE;

        difference[i] = temp[i] - b[i];
    }
}


/*****************************************************************************/


/* Convert a bunch of stuff into the final FP string to output.
 *
 * buf       : buffer where primary string result is put.
 * postfix   : buffer where to put exponent string result.
 * digits    : FP value represented in BCD format, with every byte representing
 *             one character.
 * numDigits : total number of bytes in the "digits" array
 * exponent  : exponent for the FP number.
 * conversion: conversion type, one of 'e', 'E', 'f', 'g', or 'G'
 * precision : field precision requested by user.
 * flags     : conversion flags as requested by user. This is a bitmask of the
 *             various FLG_XXX constants defined above.
 */
static int32 ConstructFPString(char *buf, char *postfix,
                               uint8 *digits, int32 numDigits,
                               int32 exponent, char conversion,
                               int32 precision, uint32 flags)
{
bool   gtrunc;
uint32 outIndex;
uint32 inIndex;
int32  digitCount;
int32  result;
int32  i;
int32  digitsBeforePoint;
int32  digitsAfterPoint;
int32  usefulDigits;
char   originalConversion;

    if (((conversion == 'g') || (conversion == 'G')) && !(flags & FLG_HASH))
        gtrunc = TRUE;
    else
        gtrunc = FALSE;

    if ((conversion == 'g') || (conversion == 'G'))
    {
        if (precision == 0)
            precision = 1;
    }

    if (precision < 0)
        precision = 6;

    /* 'e':  [-]d.dddddde[+/-]dd */
    /* 'E':  [-]d.ddddddE[+/-]dd */
    /* 'f':  [-]d.dddddd         */

    originalConversion = conversion;
    if ((conversion == 'g') || (conversion == 'G'))
    {
        if ((exponent < -4) || (exponent >= precision))
        {
            conversion = (conversion == 'g') ? 'e' : 'E';
            precision--;
        }
        else
        {
            conversion = 'f';
        }
    }

    if (conversion == 'f')
    {
        if (exponent >= 0)
        {
            digitsBeforePoint = exponent + 1;

            if ((originalConversion == 'g') || (originalConversion == 'G'))
            {
                if (digitsBeforePoint < precision)
                    digitsAfterPoint = precision - digitsBeforePoint;
                else
                    digitsAfterPoint = 0;
            }
            else
            {
                digitsAfterPoint = precision;
            }

            usefulDigits = digitsBeforePoint + digitsAfterPoint;
        }
        else
        {
            digitsBeforePoint = 0;
            digitsAfterPoint  = precision;
            usefulDigits      = digitsAfterPoint;
        }
    }
    else
    {
        digitsBeforePoint = 1;
        digitsAfterPoint  = precision;
        usefulDigits      = digitsBeforePoint + digitsAfterPoint;
    }

    if (usefulDigits < numDigits)
    {
        if (usefulDigits == 0)
            usefulDigits = 1;

        if (digits[usefulDigits] >= 5)
        {
            for (digitCount = usefulDigits - 1; digitCount >= 0; --digitCount)
            {
                digits[digitCount]++;
                if (digits[digitCount] == 10)
                {
                    if (digitCount == 0)
                    {
                        for (i = numDigits - 1; i > 0; i--)
                            digits[i] = digits[i-1];

                        digits[1] = 0;
                        digits[0] = 1;
                        exponent++;

                        if (conversion == 'f')
                        {
                            if (exponent >= 0)
                                digitsBeforePoint++;
                            else if (precision == -exponent)
                                digitsAfterPoint++;
                        }
                        break;
                    }
                    digits[digitCount] = 0;
                }
                else
                {
                    break;
                }
            }
        }
    }

    outIndex = 0;
    inIndex  = 0;

    if (digitsBeforePoint)
    {
        for (i = 0; i < digitsBeforePoint; i++)
            buf[outIndex++] = digits[inIndex++] + '0';
    }
    else
    {
        buf[outIndex++] = '0';
    }

    if (digitsAfterPoint > 0)
    {
        buf[outIndex++] = '.';
        if (precision < digitsAfterPoint)
            result = precision;
        else
            result = digitsAfterPoint;

        if ((conversion == 'f') && (exponent < 0))
        {
            i = exponent + 1;
            while ((i < 0) && (result > 0))
            {
                buf[outIndex++] = '0';
                result--;
                i++;
            }
        }

        while ((result > 0) && (inIndex < numDigits))
        {
            buf[outIndex++] = digits[inIndex++] + '0';
            result--;
        }

        if (gtrunc)
        {
            while (buf[outIndex - 1] == '0')
                outIndex--;
        }

        if ((flags & FLG_HASH) == 0)
        {
            if (buf[outIndex - 1] == '.')
                outIndex--;
        }
    }
    else if (precision && (originalConversion != 'g') && (originalConversion != 'G'))
    {
        buf[outIndex++] = '.';
        result = precision;
    }
    else
    {
        if (flags & FLG_HASH)
            buf[outIndex++] = '.';

        result = 0;
    }

    buf[outIndex] = 0;

    if (conversion != 'f')
    {
        postfix[0] = conversion;
        postfix[1] = (exponent < 0) ? '-' : '+';
        postfix[2] = (abs(exponent) / 10) + '0';
        postfix[3] = (abs(exponent) % 10) + '0';
        postfix[4] = 0;
    }

    return result;
}


/*****************************************************************************/


static int32 ConvertNormalizedFloat(char *buf, char *postfix,
                                    uint32 mantissa, int32 exponent,
                                    char conversion,
                                    int32 precision, uint32 flags)
{
uint32     binValue[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
uint192Ptr fraction;
uint32     lowHalf;
uint32     highHalf;
int16      index;
int16      bitsToShift;
int16      decimalExponent;
int16      power;
uint8      digits[48];
int16      digitCount;
int16      computeDigits;

    computeDigits = sizeof(digits) + 1;
    fraction      = &binValue[3];
    mantissa     += 0x00800000;
    bitsToShift   = (exponent + 10) % 32;
    lowHalf       = mantissa << bitsToShift;
    highHalf      = mantissa >> (32 - bitsToShift);

    index = 8 - ((exponent + 10) / 32);
    binValue[index] = lowHalf;
    if (index)
        binValue[index - 1] = highHalf;

    digitCount = 0;
    if ((exponent - 127) >= 0)
    {
        for (decimalExponent = 38; decimalExponent >= 0; --decimalExponent)
        {
            if (!Compare_uint128(tensTable[decimalExponent], binValue))
                break;
        }
    }
    else
    {
        decimalExponent = 0;
        while (fraction[0] == 0)
        {
            Mult10_uint192(fraction);
            decimalExponent--;
        }
        digits[digitCount++] = fraction[0];
    }

    for (power = decimalExponent; (power >= 0) && (digitCount < computeDigits); power--)
    {
        digits[digitCount] = 0;
        while (!Compare_uint128(tensTable[power], binValue))
        {
            digits[digitCount]++;
            Subtract_uint128(binValue, tensTable[power], binValue);
        }
        digitCount++;
    }

    while (digitCount < computeDigits)
    {
        fraction[0] = 0;
        Mult10_uint192(fraction);
        digits[digitCount++] = fraction[0];
    }

    return ConstructFPString(buf, postfix, digits, sizeof(digits), decimalExponent,
                             conversion, precision, flags);
}


/*****************************************************************************/


static int32 ConvertDenormalizedFloat(char *buf, char *postfix,
                                      uint32 mantissa, char conversion,
                                      int32 precision, uint32 flags)
{
uint192 fraction;
int16   decimalExponent;
uint8   digits[48];
int16   digitCount;
int16   computeDigits;

    if (mantissa == 0)
    {
        memset(digits, 0, sizeof(digits));
        decimalExponent = 0;
    }
    else
    {
        computeDigits = sizeof(digits) + 1;

        fraction[0] = 0;
        fraction[1] = 0;
        fraction[2] = 0;
        fraction[3] = 0;
        fraction[4] = mantissa >> (32 - 11);
        fraction[5] = mantissa << 11;

        decimalExponent = 0;
        while (fraction[0] == 0)
        {
            Mult10_uint192(fraction);
            decimalExponent--;
        }
        digits[1] = fraction[0];

        digitCount = 1;
        while (digitCount < computeDigits)
        {
            fraction[0] = 0;
            Mult10_uint192(fraction);
            digits[digitCount++] = fraction[0];
        }
    }

    return ConstructFPString(buf, postfix, digits, sizeof(digits), decimalExponent,
                             conversion, precision, flags);
}


/*****************************************************************************/


typedef struct
{
    union
    {
        float  f;
        uint32 i;
    } u;
} Combo;


/*****************************************************************************/


int vcprintf(const char *fmt, OutputFunc of, void *userData, va_list va)
{
char        ch;
int         error;
int         numChars;
int         flags;
int         width;
int         precision;
LineBuffer  lb;
bool        flush;
bool        done;
const char *prefix;
char       *value;
char        postfix[8];
char        buf[64];
int         len;
int         leading_zeroes;
int         trailing_zeroes;
int         i;

    flush = FALSE;
    if (of == NULL)
    {
        of             = (OutputFunc)DefaultOutputFunc;
        userData       = &lb;
        flush          = TRUE;
        lb.lb_NumBytes = 0;
    }

    error    = 0;
    numChars = 0;
    while (ch = *fmt++)
    {
        if (ch != '%')
        {
            output(ch);
            continue;
        }

        /* %[flags][width][.precision][size]type */

        /* isolate the flags */
        flags = 0;
        done  = FALSE;
        do
        {
            ch = *fmt++;
            switch (ch)
            {
                case '-': flags |= FLG_MINUS; break;
                case '+': flags |= FLG_PLUS;  break;
                case ' ': flags |= FLG_SPACE; break;
                case '#': flags |= FLG_HASH;  break;
                case '0': flags |= FLG_ZERO;  break;
                default : done = TRUE;        break;
            }
        }
        while (!done);

        /* get the field width */
        if (ch == '*')
        {
            width = va_arg(va, int);
            if (width < 0)
            {
                flags |= FLG_MINUS;
                width = -width;
            }

            ch = *fmt++;
        }
        else if ((ch >= '0') && (ch <= '9'))
        {
            width = 0;
            do
            {
                width = width * 10 + (ch - '0');
                ch = *fmt++;
            }
            while ((ch >= '0') && (ch <= '9'));
        }
        else
        {
            /* unlimited */
            width = -1;
        }

        /* get the field precision */
        if (ch == '.')
        {
            ch = *fmt++;
            if (ch == '*')
            {
                precision = va_arg(va, int);
                if (precision < 0)
                    precision = 0;

                ch = *fmt++;
            }
            else
            {
                precision = 0;
                while ((ch >= '0') && (ch <= '9'))
                {
                    precision = precision * 10 + (ch - '0');
                    ch = *fmt++;
                }
            }
        }
        else
        {
            /* unlimited */
            precision = -1;
        }

        /* isolate the size */
        while (TRUE)
        {
            if (ch == 'h')
            {
                flags |= FLG_SHORT;
                ch = *fmt++;
            }
            else if (ch == 'l')
            {
                flags |= FLG_LONG;
                ch = *fmt++;
            }
            else if (ch == 'L')
            {
                flags |= FLG_DLONG;
                ch = *fmt++;
            }
            else
            {
                break;
            }
        }

        value           = "";
        len             = 0;
        prefix          = "";
        postfix[0]      = 0;
        leading_zeroes  = 0;
        trailing_zeroes = 0;

        switch (ch)
        {
            case 'i':
            case 'd':
                      {
                      int64 num;

                          if (flags & FLG_DLONG)
                              num = va_arg(va, int64);
                          else
                              num = va_arg(va, int);

                          if (num < 0)
                          {
                              num = -num;
                              prefix = "-";
                          }

                          if (precision < 0)
                              precision = 1;

                          len = 0;
                          do
                          {
                              len++;
                              buf[sizeof(buf) - len] = num % 10 + '0';
                              num /= 10;
                          }
                          while (num);
                          value = &buf[sizeof(buf) - len];

                          if (precision > len)
                          {
                              leading_zeroes = precision - len;
                              len            = precision;
                          }
                      }
                      break;

            case 'u':
            case 'o':
                      {
                      uint64       num;
                      unsigned int base;

                          if (ch == 'o')
                              base = 8;
                          else
                              base = 10;

                          if (flags & FLG_DLONG)
                              num = va_arg(va, uint64);
                          else
                              num = va_arg(va, unsigned int);

                          if (precision < 0)
                              precision = 1;

                          if ((ch == 'o') && num)
                              prefix = "0";

                          len = 0;
                          do
                          {
                              len++;
                              buf[sizeof(buf) - len] = num % base + '0';
                              num /= base;
                          }
                          while (num);
                          value = &buf[sizeof(buf) - len];

                          if (precision > len)
                          {
                              leading_zeroes = precision - len;
                              len            = precision;
                          }
                      }
                      break;

            case 'p':
            case 'P':
            case 'x':
            case 'X': {
                      uint64      num;
                      const char *map;

                          if (flags & FLG_DLONG)
                              num = va_arg(va, uint64);
                          else
                              num = va_arg(va, unsigned int);

                          if ((ch == 'X') || (ch == 'P'))
                              map = "0123456789ABCDEF";
                          else
                              map = "0123456789abcdef";

                          if (flags & FLG_HASH)
                          {
                              if (ch == 'X')
                                  prefix = "0X";
                              else if (ch == 'x')
                                  prefix = "0x";
                              else
                                  prefix = "@";
                          }

                          if (precision < 0)
                          {
                              if ((ch == 'p') || (ch == 'P'))
                                  precision = 8;
                              else
                                  precision = 1;
                          }

                          len = 0;
                          do
                          {
                              len++;
                              buf[sizeof(buf) - len] = map[num & 15];
                              num /= 16;
                          }
                          while (num);
                          value = &buf[sizeof(buf) - len];

                          if (precision > len)
                          {
                              leading_zeroes = precision - len;
                              len            = precision;
                          }
                      }
                      break;

            case 'n': if (flags & FLG_DLONG)
                          *((uint64 *)va_arg(va, uint64 *)) = numChars;
                      else if (flags & FLG_SHORT)
                          *((uint16 *)va_arg(va, uint16 *)) = numChars;
                      else
                          *((uint32 *)va_arg(va, uint32 *)) = numChars;
                      break;

            case 's': value = va_arg(va, char *);
                      if (value == NULL)
                          value = "<NULL>";

                      while ((precision < 0 || len < precision) && value[len])
                          len++;
                      break;

            case 'e': /* [-]d.dddddde[+/-]dd                             */
            case 'E': /* [-]d.ddddddE[+/-]dd                             */
            case 'f': /* [-]d.dddddd                                     */
            case 'g': /* if exp < -4 or exp > prec use 'e', else use 'f' */
            case 'G': /* if exp < -4 or exp > prec use 'E', else use 'f' */

                      {
                      uint32 mantissa;
                      uint32 exponent;
                      uint32 sign;
                      Combo  c;

                          c.u.f    = va_arg(va, FLOAT);
                          mantissa = (c.u.i & 0x007fffff);
                          exponent = (c.u.i & 0x7f800000) >> 23;
                          sign     = (c.u.i >> 31);

                          if (sign)
                              prefix = "-";

                          if (exponent == 0)
                          {
                              trailing_zeroes = ConvertDenormalizedFloat(buf, postfix, mantissa, ch, precision, flags);
                              value           = buf;
                          }
                          else if (exponent == 255)
                          {
                              if (mantissa)
                              {
                                  value = "NaN";
                              }
                              else
                              {
                                  if (sign)
                                      value = "-Infinity";
                                  else
                                      value = "Infinity";
                              }
                          }
                          else
                          {
                              trailing_zeroes = ConvertNormalizedFloat(buf, postfix, mantissa, exponent, ch, precision, flags);
                              value           = buf;
                          }
                          len = strlen(value);
                      }
                      break;

            case 0  : output('%');
                      goto exit;

            case 'c': ch = va_arg(va, int);

                      /* FALLS THROUGH */

            default : /* Handle unknown formatting commands like %c,
                       * by just printing the command character using the
                       * specified width and precision. This is how %% is
                       * handled.
                       */
                      buf[0] = ch;
                      len    = 1;
                      value  = buf;
                      break;
        }

        if (prefix[0] == 0)
        {
            if (flags & FLG_PLUS)
                prefix = "+";
            else if (flags & FLG_SPACE)
                prefix = " ";
        }
        else if (flags & FLG_ZERO)
        {
            /* prefix goes before zero padding, but after space padding */

            i = 0;
            while (prefix[i])
                output(prefix[i++]);

            width -= i;
        }

        if ((width > 0) && ((flags & FLG_MINUS) == 0))
        {
        int  j;
        char fillChar;

            j        = width - strlen(prefix) - len - strlen(postfix);
            fillChar = (flags & FLG_ZERO) ? '0' : ' ';

            if (j > 0)
            {
                width -= j;
                while (j-- > 0)
                    output(fillChar);
            }
        }

        if ((flags & FLG_ZERO) == 0)
        {
            i = 0;
            while (prefix[i])
                output(prefix[i++]);

            width -= i;
        }

        len -= leading_zeroes;
        while (leading_zeroes--)
            output('0');

        i = 0;
        while (i < len)
            output(value[i++]);

        width -= len;

        if (trailing_zeroes > 0)
        {
            width -= trailing_zeroes;
            while (trailing_zeroes--)
                output('0');
        }

        i = 0;
        while (postfix[i])
            output(postfix[i++]);

        width -= i;

        if (flags & FLG_MINUS)
        {
            /* handle padding for left-justified field */

            if (width > 0)
            {
                while (width-- > 0)
                    output(' ');
            }
        }
    }

exit:

    if (flush)
        FlushLineBuffer(&lb);

    if (error < 0)
        return error;

    return numChars;
}


/*****************************************************************************/


#ifndef FOR_PORTFOLIO
int out(const char *fmt, ...)
{
va_list va;
int32   result;

    va_start(va, fmt);
    result = vcprintf(fmt, NULL, NULL, va);
    va_end(va);

    return result;
}


typedef struct
{
    char  *ft_Format;
    float  ft_Float;
} FloatTest;

static const FloatTest floatTests[] =
{
    {"%g", 0.12078},
    {"%e", 0.12078},
    {"%f", 0.12078},

    {"%g", 12078.457},
    {"%e", 12078.457},
    {"%f", 12078.457},

    {"%g", 1.457},
    {"%e", 1.457},
    {"%f", 1.457},

    {"%g", 12.457},
    {"%e", 12.457},
    {"%f", 12.457},

    {"%g", 0.0},
    {"%f", 0.0},
    {"%e", 0.0},

    {"%g", 1.0},
    {"%f", 1.0},
    {"%e", 1.0},

    {"%.g",  10.456},
    {"%.0g", 10.456},
    {"%.0g", 1.5},
    {"%.1g", 1.5},
    {"%.2g", 1.5},
    {"%#.3g", 1.5},

    {"'%10.1f'", 10.39},
    {"'%10.2f'", 10.39},
    {"'%10.3f'", 10.39},

    {"%.1f", 9.99},
    {"%.1f", 0.99},
    {"%.1f", 0.099},
    {"%.1f", 0.009},

    {"%9.6f", 0.0001},
    {"%g", 4.5e-2},
    {"%g", 4.5e-3},
    {"%f", 4.5e-4},
    {"%g", 4.5e-5},
    {"%g", 4.5e-4},

    {"%.0f", 1.5}
};

int main(void)
{
int i;

    for (i = 0; i < sizeof(floatTests) / sizeof(floatTests[0]); i++)
    {
        printf("%-2d - %s\n     ", i, floatTests[i].ft_Format);
        out(floatTests[i].ft_Format, floatTests[i].ft_Float);
        printf("\n     ");
        printf(floatTests[i].ft_Format, floatTests[i].ft_Float);
        printf("\n\n");
    }
}
#endif
