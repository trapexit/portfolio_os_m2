/*
* Load of functions called by the parser.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "../parser.h"
#include "write.h"
#include "../parsererrors.h"

#define STRLEN 256
#define CLASS_INC 0x00010000
#define ARRAY_INC 0x01000000
#define CLASS_PRE "CLASS_"
#define ENUM_PRE "ENUM_"
#define ARRAY_PRE "ARRAY_"

FILE *outFile;
uint32 arrayCount = 0x03000000;
uint32 classCount = 0;
uint32 dataCount;

char className[STRLEN];
char enumName[STRLEN];
char word[STRLEN];
void MakeUC(char *word);

void MakeUC(char *word)
{
    int32 i = 0;
        
        /* make all uppercase */
    while (word[i] != '\0')
    {
        if ((word[i] >= 'a') && (word[i] <= 'z'))
        {
            word[i] -= ('a' - 'A');
        }
        i++;
    }
}

char *headLines[] =
{
    "/* Header file for tokenised sdf data types. */\n",
    "/* This file is automatically generated by mkheader */\n",
    "\n",
    "#include \"parsertypes.h\"\n",
    "\n",
    "#define NEXT_BUFFER 0xffffffff\t/* For joining buffers together */\n",
    "#define CLASS_PAD 0x0000ffff\n",
    "#define SDF_UNITS 0x0000fffe\n",
    "#define USE_SYMBOL 0x0000fffd\n",
    "#define SYMBOL_NAME 0x0000fffc\n",
    "\n",
    "typedef struct TokenHead\n",
    "{\n",
    "\tuint32 flags;\n",
    "\tfloat version;\n",
    "\tuint32 size;\n",
    "} TokenHead;\n",
    "#define TH_ADDR_DELTA 1\t/* Addresses are delta values */",
    "\n",
    "#define ADDRESS(th, c, o) \\\n",
    "(((th)->flags & TH_ADDR_DELTA) ? \\\n",
    " ((uint32)(c) + (o)) : (o))\n",
    "\n\n",
    "/* These are the values for the units */\n"
    "enum ENUM_UNITS\n",
    "{\n",
    "\tENUM_UNITS_METERS = 0,\n",
    "\tENUM_UNITS_KMETERS,\n",
    "\tENUM_UNITS_FEET,\n",
    "\tENUM_UNITS_INCHES,\n",
    "\tENUM_UNITS_NAUTMILES,\n",
    "\tENUM_UNITS_INTEGER\n",
    "};\n",
    "\n\n",
};


Err WriteHeader(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    uint32 i;
    
    for (i = 0; i < (sizeof(headLines) / sizeof(char *)); i++)
    {
        fprintf(outFile, headLines[i]);
    }
    
    return(NO_ERROR);
}

Err IncClassCounter(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    classCount += CLASS_INC;
    dataCount = 1;
    
    return(NO_ERROR);
}

Err IncArrayCounter(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    arrayCount += ARRAY_INC;
    
    return(NO_ERROR);
}

Err mhFoundDefineArray(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    /* Make the array name string */
    strcpy(className, ARRAY_PRE);
    strncpy((className + strlen(ARRAY_PRE)), wordIn, charCount);
    className[strlen(ARRAY_PRE) + charCount] = '\0';
    MakeUC(className);

    /* Write out the class declarer */
    fprintf(outFile, "#define %s 0x%lx\n", className, arrayCount);
    
    return(NO_ERROR);
}

bool firstClassLine;
Err mhFoundDefineClass(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    /* Make the class name string */
    strcpy(className, CLASS_PRE);
    strncpy((className + strlen(CLASS_PRE)), wordIn, charCount);
    className[strlen(CLASS_PRE) + charCount] = '\0';
    MakeUC(className);

    /* Write out the class declarer */
    fprintf(outFile, "#define %s 0x%lx\n", className, classCount);
    fprintf(outFile, "enum e%s\n{\n", className);
    firstClassLine = TRUE;
    
    return(NO_ERROR);
}

Err mhHandleClassString(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    /* This is the name of the data type in the class */
    if (!firstClassLine)
    {
        fprintf(outFile, ",\n");
    }
    firstClassLine = FALSE;

    fprintf(outFile, "\t%s_", className);
    strncpy(word, wordIn, charCount);
    word[charCount] = '\0';
    MakeUC(word);
    fprintf(outFile, "%s = 0x%lx", word, (classCount + dataCount));
    dataCount++;
    return(NO_ERROR);
}

Err EndClassDefinition(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    if (dataCount == 1)
    {
        /* Must be an empty definition. Need at least one enumerated value! */
        fprintf(outFile, "\t%s_dummy = 0\t/* An empty definition */", className);
    }
    fprintf(outFile, "\n};\n\n");
    return(NO_ERROR);
}

bool firstEnumLine;
Err EndEnumDefinition(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    fprintf(outFile, "\n};\n\n");
    return(NO_ERROR);
}

Err mhFoundDefineEnum(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    /* Make the class name string */
    strcpy(enumName, ENUM_PRE);
    strncpy((enumName + strlen(ENUM_PRE)), wordIn, charCount);
    enumName[strlen(ENUM_PRE) + charCount] = '\0';
    MakeUC(enumName);

    /* Write out the class declarer */
    fprintf(outFile, "enum %s\n{\n", enumName);
    firstEnumLine = TRUE;
    
    return(NO_ERROR);
}

Err HandleEnumString(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    /* This is the name of the data type in the class */
    if (!firstEnumLine)
    {
        fprintf(outFile, ",\n");
    }
    firstEnumLine = FALSE;
    
    fprintf(outFile, "\t%s_", enumName);
    strncpy(word, wordIn, charCount);
    word[charCount] = '\0';
    MakeUC(word);
    fprintf(outFile, "%s = ", word);
    return(NO_ERROR);
}

Err HandleEnumValue(char **buff, char *wordIn, uint32 charCount, SyntaxResult *sr)
{
    /* This is the value of the enumerated name */
    strncpy(word, wordIn, charCount);
    word[charCount] = '\0';
    fprintf(outFile, "%s", word);
    return(NO_ERROR);
}

