/******************************************************************************
**
**  @(#) dbuf.c 96/09/25 1.1
**
******************************************************************************/

/**
|||	AUTODOC -public -class Examples -group Graphics -name dbuf
|||	Illustrates the correct way to use render and display signals for
|||	double buffering.
|||
|||	  Synopsis
|||
|||	    dbuf
|||
|||	  Description
|||
|||	    This program demonstrates the correct usage of render and
|||	    display signals for the purposes of double-buffering, and the
|||	    visual artifacts that can result when used improperly or not at
|||	    all.
|||
|||	    Additionally, this program also illustrates how to create and
|||	    make visible a View without generating spurious render or
|||	    display signals.
|||
|||	  What to Do and Notice
|||
|||	    Launch 'dbuf' from an M2 shell prompt.  You will see a small
|||	    View 50 pixels tall with a small colored rectangle bouncing back
|||	    and forth.  The rectangle will be torn and moving across the
|||	    screen quite rapidly.  This is because, when initially launched,
|||	    dbuf does not wait for any signals from the graphics folio, so
|||	    the rectangle will be torn as half-rendered frames are scanned
|||	    out to the monitor.  dbuf can also render frames several times
|||	    over one video field, so the rectangle will bounce quite rapidly
|||	    as frames are "dropped."
|||
|||	    Now, press the A button on the control pad once.  This causes
|||	    dbuf to start waiting for the render signal.  Notice that,
|||	    though still moving quite rapidly, the rectangle is no longer
|||	    torn.  This is because, by waiting for the render signal, the
|||	    program does not attempt to make changes to the Bitmap until the
|||	    previous View state has become invisible.  Press the C button to
|||	    restore the original display method.
|||
|||	    Now, press the B button.  This causes dbuf to start waiting for
|||	    the display signal.  Notice that the rectangle has slowed down
|||	    and is moving smoothly, but is still torn.  Waiting for the
|||	    display signal prevents the program from making new changes to
|||	    the View before the previous change has become visible.  Press
|||	    the C button to restore the original display method.
|||
|||	    Now, press the A button, followed by the B button.  dbuf will
|||	    now wait for both the render and display signals.  Notice that
|||	    the rectangle moves smoothly across the screen, and is
|||	    tear-free.  Waiting for the render signal prevents tearing;
|||	    waiting for the display signal prevents rendering frames too
|||	    quickly.
|||
|||	    For a more intriguing example, press the C button to restore the
|||	    startup mode, then press the B button (enables waiting for
|||	    display signals), followed by the A button (wait for render
|||	    signals).  Notice that the display is still tearing.  This is
|||	    because an unconsumed render signal is still present, which
|||	    causes the next call to WaitSignal() to return immediately.
|||	    However, the desired render signal may not arrive for some time.
|||	    (ModifyGraphicsItem() does not clear previously-dispatched
|||	    signals.)  Thus, the program forever remains out of sync,
|||	    proceeding on the render signal generated by the *previous* call
|||	    to ModifyGraphicsItem().  This is why it is important to assure
|||	    there are no spurious render signals generated before entering
|||	    the main loop.
|||
|||	  User Control
|||
|||	    The buttons on the control pad have the following functions:
|||
|||	    A Button
|||	        Toggles waiting for render signals.
|||
|||	    B Button
|||	        Toggles waiting for display signals.
|||
|||	    C Button
|||	        Causes program to not wait for either signal.
|||
|||	    Stop
|||	        Quits the program.
|||
|||	  Associated Files
|||
|||	    dbuf.c
|||
|||	  Location
|||
|||	    examples/graphics/graphicsfolio
|||
|||	  See Also
|||
|||	    basicview(@)
|||
**/

#include <kernel/types.h>
#include <kernel/item.h>
#include <kernel/time.h>
#include <kernel/mem.h>
#include <kernel/cache.h>
#include <misc/event.h>
#include <graphics/graphics.h>
#include <graphics/bitmap.h>
#include <graphics/view.h>
#include <stdio.h>
#include <stdlib.h>


/***************************************************************************
 * #defines
 */
#define	WIDE		320
#define	HIGH		50


/***************************************************************************
 * Prototypes.
 */
/* dbuf.c */
int main(int ac, char **av);
Item allocbitmap(int32 wide, int32 high, int32 type);
void fillrast16(struct Bitmap *bm, uint32 r, uint32 g, uint32 b);
void rectfill16(struct Bitmap *bm, int32 x, int32 y, int32 w, int32 h, int color);
uint16 colorwheel(uint32 rot);
uint32 getjoybits(long shiftbits);
void openstuff(void);
void closestuff(void);
void die(Err err, char *str);


/***************************************************************************
 * Global variables.
 */


/***************************************************************************
 * Code.
 */
int
main (ac, av)
int	ac;
char	**av;
{
	Bitmap	*bm0, *bm1, *bmrend;
	Item	vi, bmi0, bmi1;
	Err	err;
	int32	x, y, w, h, dx, dy;
	uint32	rendsig, dispsig;
	uint32	colorrot, joybits, sigstate;
	uint16	color;

	TOUCH (av);	/*  Get the compiler to shut up.  */
	TOUCH (ac);

	/*
	 * Open some rudimentary stuff and allocate signals.
	 */
	openstuff ();

	if ((rendsig = AllocSignal (0)) <= 0)
		die (rendsig, "Can't allocate render signal.\n");
	if ((dispsig = AllocSignal (0)) <= 0)
		die (dispsig, "Can't allocate display signal.\n");

	/*
	 * Create the Bitmaps.
	 */
	bmi0 = allocbitmap (WIDE, HIGH, BMTYPE_16);
	bmi1 = allocbitmap (WIDE, HIGH, BMTYPE_16);
	bm0 = LookupItem (bmi0);
	bm1 = LookupItem (bmi1);
	bmrend = bm1;

	/*
	 * Create the View through which the Bitmap will be made visible.
	 *
	 * AddViewToViewLists() can cause a signal to be generated, which we
	 * don't want.  So we create the View, add it to the default
	 * Projector, then install the signals.  We use VIEWTAG_BESILENT to
	 * prevent the signals from being sent.
	 */
	if ((vi = CreateItemVA (MKNODEID (NST_GRAPHICS, GFX_VIEW_NODE),
				VIEWTAG_VIEWTYPE, VIEWTYPE_16,
				VIEWTAG_BITMAP, bmi0,
				VIEWTAG_TOPEDGE, 100,
				TAG_END)) < 0)
		die (vi, "Can't create View.\n");

	if ((err = AddViewToViewList (vi, 0)) < 0)
		die (err, "AddViewToViewList() failed.\n");

	if ((err = ModifyGraphicsItemVA (vi,
					 VIEWTAG_RENDERSIGNAL, rendsig,
					 VIEWTAG_DISPLAYSIGNAL, dispsig,
					 VIEWTAG_BESILENT, TRUE,
					 TAG_END)) < 0)
		die (err, "Can't modify for signals.\n");


	/*
	 * Set up the show, and start bouncing things around.
	 */
	sigstate = 0;
	colorrot = 0;
	x = y = 0;
	w = 16;		/*  Size and velocity of the rectangle.  */
	h = 32;
	dx = 3;
	dy = 1;
	while (1) {
		/*
		 * Flip pages.
		 *
		 * This will cause both the Render and Display signals to be
		 * dispatched.  Depending on the joystick input, we may wait
		 * for these signals or ignore them, with differing visual
		 * results.
		 *
		 * By placing the call to ModifyGraphicsItem() at the top of
		 * the loop, we avoid having to "pre-seed" the loop with
		 * signals.
		 */
		if ((err = ModifyGraphicsItemVA
			    (vi,
			     VIEWTAG_BITMAP, bmrend->bm.n_Item,
			     TAG_END)) < 0)
			die (err, "Double-buffering modify failed.\n");

		/*
		 * User input/computation cycle.
		 */
		joybits = getjoybits (0);
		if (joybits & ControlX)
			break;
		if (joybits & ControlA)
			sigstate ^= 1;
		if (joybits & ControlB)
			sigstate ^= 2;
		if (joybits & ControlC)
			sigstate = 0;

		if (bmrend == bm0)	bmrend = bm1;
		else			bmrend = bm0;

		x += dx;
		y += dy;
		if (x < 0) {
			x = 0;
			dx = -dx;
		} else if (x > WIDE - w) {
			x = WIDE - w;
			dx = -dx;
		}
		if (y < 0) {
			y = 0;
			dy = -dy;
		} else if (y > HIGH - h) {
			y = HIGH - h;
			dy = -dy;
		}
		color = colorwheel (colorrot);
		colorrot += 0x100;

		/*
		 * Rendering cycle.
		 */
		if (sigstate & 1)
			/*
			 * Wait until it is safe to render.
			 */
			WaitSignal (rendsig);

		fillrast16 (bmrend, 0, 0, 0);
		rectfill16 (bmrend, x, y, w, h, color);
		WriteBackDCache (0, bmrend->bm_Buffer, bmrend->bm_BufferSize);

		/*
		 * Page flip will happen on next loop; wait until it's safe.
		 */
		if (sigstate & 2)
			/*
			 * Wait until the previous View modifications have
			 * become visible.
			 */
			WaitSignal (dispsig);
	}

	closestuff ();
	printf ("Normal exit.\n");
	return (0);
}



Item
allocbitmap (wide, high, type)
int32	wide, high, type;
{
	Bitmap	*bm;
	Item	bmi;
	Err	err;
	void	*buf;

	/*
	 * Create Bitmap Item.
	 * The Bitmap Item structure will be filled in according to our
	 * needs.  We can then inspect the structure to discover memory
	 * requirements, correct widths, etc.
	 */
	bmi = CreateItemVA (MKNODEID (NST_GRAPHICS, GFX_BITMAP_NODE),
			    BMTAG_WIDTH, wide,
			    BMTAG_HEIGHT, high,
			    BMTAG_TYPE, type,
			    BMTAG_DISPLAYABLE, TRUE,
			    BMTAG_RENDERABLE, TRUE,
			    BMTAG_BUMPDIMS, TRUE,
			    TAG_END);

	if (bmi < 0)
		die (bmi, "Bitmap creation failed.\n");
	bm = LookupItem (bmi);

	/*
	 * Create the Bitmap buffer.
	 * In this case (which will be the most common), we accomplish this
	 * by creating a RenderBuffer Item.
	 */
	if (!(buf = AllocMemMasked (bm->bm_BufferSize,
				    bm->bm_BufMemType,
				    bm->bm_BufMemCareBits,
				    bm->bm_BufMemStateBits)))
		die (0, "Can't allocate Bitmap buffer.\b");

	/*
	 * Attach buffer to Bitmap.
	 */
	if ((err = ModifyGraphicsItemVA (bmi,
					 BMTAG_BUFFER, buf,
					 TAG_END)) < 0)
		die (err, "Can't modify Bitmap Item.\n");

	/*
	 * Success.  Return the Bitmap Item number.
	 */
	return (bmi);
}


/***************************************************************************
 * This incredibly lame routine fills a Bitmap with the specified color.
 * The color is specified as three 32-bit unsigned values (overkill).
 * Assumes a 16-bit buffer.
 */
void
fillrast16 (bm, r, g, b)
struct Bitmap   *bm;
uint32          r, g, b;
{
        register int    i;
        int32           size;
        uint32          color, *buf;

        size = bm->bm_BufferSize;
        buf = bm->bm_Buffer;

        color = ((r & 0xF8000000) >> 1)  |
                ((g & 0xF8000000) >> 6)  |
                ((b & 0xF8000000) >> 11);
        color = color | (color >> 16);
        for (i = size / sizeof (uint32);  --i >= 0; )
                *buf++ = color;
}


void
rectfill16 (bm, x, y, w, h, color)
struct Bitmap	*bm;
int32	x, y, w, h;
uint16	color;
{
	uint16	*pix, *line;
	int32	cw, ch, stride;

	if (!(line = PixelAddress (bm->bm.n_Item, x, y)))
		die (0, "What pixel?\n");

	stride = bm->bm_Width;

	for (ch = h;  --ch >= 0; ) {
		pix = line;
		for (cw = w;  --cw >= 0; )
			*pix++ = color;
		line += stride;
	}
}


/***************************************************************************
 * A cheesy little colorwheel routine (just 'cuz).  'rot' expresses
 * rotation around the colorwheel as a fixed point fraction.  0x10000 equals
 * 360 degrees.
 *
 * Math/graphics whizes will note that the conversion isn't perfect.
 */
uint16
colorwheel (rot)
uint32	rot;
{
	int32	phase;
	uint32	third, sixth;
	uint32	r, g, b;


	rot &= 0xFFFF;
	phase = 6 * rot / 0x10000;
	third = 0x10000 / 3;
	sixth = third / 2;
	r = g = b = 0;

	if (rot < third) {
		r = 255;
		if (phase & 1)
			g = 256 * (rot - sixth) / sixth;
		else
			b = 256 * (sixth - rot) / sixth;
	} else if (rot >= 2 * third) {
		b = 255;
		if (phase & 1)
			r = 256 * (rot - 0x10000 + sixth) / sixth;
		else
			g = 256 * (0x10000 - sixth - rot) / sixth;
	} else {
		g = 255;
		if (phase & 1)
			b = 256 * (rot - third - sixth) / sixth;
		else
			r = 256 * (third + sixth - rot) / sixth;
	}
	if (r > 255)	r = 255;
	if (g > 255)	g = 255;
	if (b > 255)	b = 255;

	return (((r & 0xF8) << 7)  |  ((g & 0xF8) << 2)  |  (b >> 3));
}


/***************************************************************************
 * Returns newly pressed bits in joystick.
 */
uint32
getjoybits (shiftbits)
long	shiftbits;
{
	static uint32		prevbits;
	register uint32		newbits, changed;
	ControlPadEventData	cped;

	/*  Which bits have changed since last test?  */
	if (GetControlPad (1, FALSE, &cped) < 0) {
		printf ("GetControlPad() failed.\n");
		return (0);
	}
	newbits = cped.cped_ButtonBits;
	changed = newbits ^ prevbits;

	/*  Return only positive transitions.  */
	changed = changed & newbits;

	/*  OR in current state of "shift" bits.  */
	changed |= newbits & shiftbits;
	prevbits = newbits;
	return (changed);
}


/***************************************************************************
 * Housekeeping.
 */
void
openstuff ()
{
	Err	err;

	/*
	 * Open the graphics folio.
	 * This step must be done before any other graphics folio function
	 * may be used.
	 */
	if ((err = OpenGraphicsFolio ()) < 0)
		die (err, "Can't open graphics folio.\n");

	if (InitEventUtility (1, 0, LC_Observer) < 0)
		die (0, "Failed to InitEventUtility\n");
}

void
closestuff ()
{
	CloseGraphicsFolio ();
}

void
die (err, str)
Err	err;
char	*str;
{
	if (err < 0)
		PrintfSysErr (err);
	printf ("%s", str);
	closestuff ();
	exit (20);
}
